我将从以下几个方面来聊一聊我的观后感。

- [什么才是好代码?](#什么才是好代码？)
- [把错误关在笼子里的五道关卡](#把错误关在笼子里的五道关卡)
- [优秀的程序员](#优秀的程序员)
- [代码规范](#代码规范)
- [怎么给代码起一个好名字](#怎么给代码起一个好名字)
- [代码注释，真的那么重要吗？](#代码注释，真的那么重要吗？)
- [异常处理的陷阱](#异常处理的陷阱)



## 什么才是好代码？

###  好代码和坏代码		

​		怎么样才算是一个好的代码呢？在之前，我认为简洁易懂的代码就是好代码。然而实际上，我在学习设计模式时，总是会为了设计而去设计。这样子带来的结果是，我自己莫名其妙的得到了满足感，但是我的代码却没有我想象中这么好看。或者说，我写了一堆好像是好代码的坏代码。

​		书中给出了好代码的标准，我个人还是比较认同的。

- 容易理解

- 没有明显的**安全问题**

- 有充分的注释

- 使用**规范**的命名

- 经过充分的测试

  ​	那么与之对应，书中也给出了坏代码的特征：

1. 难以阅读的代码

2. 浪费大量计算机资源的代码（好吧，我想到了一个thread排序的例子）

3. 代码风格混乱的代码

4. 复杂的，不直观的代码

5. 没有经过适当测试的代码。

   ​	实际上，我个人认为，**难以阅读的代码**和**复杂的不直观的代码**实际上说的是同一的东西，就是难以理解的代码。

而**浪费大量计算机资源的代码**，我确实想到了一个案例。公司要求排序，正常我们都会选择冒泡排序，快速排序等等，有一个程序员另辟蹊径，我用一段代码来展示一下他的骚操作。

```java
public void threadSort(int[] nums) throws Exception{
    for (int i = 0 ; i < nums.length ; i ++){
        Thread.sleep(i);
    }
}
```

​		这样子是以排序的，但是确实耗费了大量的资源。

### 经济代码

​		书中还提到了一个很关键的词语——经济。

​		一个好的代码必定是经济的代码。对于创业公司，我们没有办法要求他们的代码满足各式各样的规范。创业公司的目标只有一个，活下去并且快速赚到钱。那么在创业公司的好代码标准就是快速且相对可靠。而对于大公司，追求的自然是高可靠性。

​		不难看出，**最适合当前现实环境的代码，才是最优秀的代码。**

​		关于经济代码，书中也给出了一些标准：

- 代码写的又快又好，是经济代码；代码写得快，但是错误多，不是一个经济行为

- 代码跑的又快又好，是经济代码；代码跑的快，但是安全问题突出，不是一个经济代码

- 代码写的简洁易懂，是经济代码；过分简洁，没人看得懂，不是一个经济代码。

  总计一下，就是快速，安全，易懂。

## 把错误关在笼子里的五道关卡

​		我们常说，`人非圣贤，孰能无过`。对于程序员而言，何尝不是如此。我们常以为优秀的程序员是不会犯错的，而事实呢？2014年4月份，苹果公司的IOS和OSX操作系统爆出严重安全漏洞。而造成这个安全漏洞的代码，却是简单至极。

```c
if ((error = doSomething()) != 0)
    goto fail;
	goto fail;
if ((error = doMore()) != 0)
    goto fail;
fail:
	return error;
```

​		这段代码存在什么问题呢？如果error 不满足`doSomething`，那么error永远不会去判断error = `doMore()`这个场景。而是一直跳转到fail。我在写这段代码的时候十分难受，因为没有花括号，没有缩进。那如果我将这段代码改造一下呢？

```c
if ((error = doSomething()) != 0){
    goto fail;
}   
goto fail;
if ((error = doMore()) != 0){
    goto fail;
}
fail:
	return error;
```

​		这样子错误是不是很容易就看出来了呢？

​		人人都会犯错，就算是苹果的工程师也不例外。那么怎么才能减少错误呢？

​		书中给了五个关卡，分别是：程序员，编译器，回归测试，代码评审，代码分析。

​		我自己本身就是程序员。就程序员这一块，我认为需要多去看看代码规范相关的书籍。或者说，多去看看提升编码能力的书籍。

​		针对于编译器来说，目前idea是支持阿里推出的《代码规约》的。一旦出现类似的错误，编译器会立刻提醒程序员。

​		回归测试的话，我认为需要涵盖足够多的场景。

​		代码评审实际上就是用人工的方式来评审代码。这需要评审人和程序员的规范保持一致，不然这项工作会因为代码习惯的不同而导致来回返工。

​		代码分析就是采用一些静态的代码分析工具，比如FindBugs。

## 优秀的程序员

​		什么是优秀的程序员呢？在我毕业的哪一年，我看过一篇文章，文章类似于小王子，以我为第一视角，来讲述我遇到的不同的程序员。其中有埋头苦干的，有关注于技术的，有一定要使用新技术的，有不断否定自己的，也有发誓要让用户拥有最好体验的。遇到的越多，思考越多，文章的最后，“我”选择的是解决用户问题的道路。

​		对于优秀程序员的定义，书中给出了六个标准，掌握一门语言、解决现实问题、发现关键问题、沉静的前行者、可以依赖的伙伴以及时间管理者。

### 掌握一门语言

​		掌握一门语言无需多说。语言本就是我们的工具，是饭碗，硬工具。掌握好一门语言，我们至少可以更快的写代码，而不用到处查询API。

### 解决现实问题

​		这个特性我也是到上一家公司才特别有感触。刚好上一家公司有几个技术导向的同事，一天到晚都是在聊技术相关的话题，然而你如果问他们业务相关的事情，他们则会破口大骂，认为业务都是次要的，技术才是唯一的正路。我其实对于他们的观点不甚认同。

​		所有的技术演变，都是源于技术。

​		仔细想一下，现在web技术的发展历史。从一开始的单体应用，随后的分布式系统，到现在的微服务理念。本质上是技术无法满足业务的需求。

​		技术从来不是程序员追求的核心。在我看来，核心是解决现实问题。一个好的且真实的作品，都带着我们对现实问题的理解。而打磨这样一个产品，需要缜密的逻辑、突破创新和贯彻执行。通过使用合适的工具，把简单的代码，耐心的粘合，打磨成优秀的作品。

​		当然，我们在接受新技术时，难免会朝技术至上的方向靠拢，我也不例外。把一段臭代码重构，学好一个新的技术，应用很多种设计模式，写出一段让自己满意到偷笑的代码，这些想一想都让人热血沸腾。这个时候，还是需要冷静一下，仔细想想我写的代码到底解决了什么问题？我还需要做什么才能让我的 产品更加完美？

### 发现关键问题

​		能够发现关键的问题，我觉得是一个好程序员和优秀程序员的分水岭。能够发现关键的问题，意味着我们可以从一个被动的做事情的程序员，升级为一个主动找事情的程序员。

​		关于这一点，我认为和`OKR`有异曲同工之妙。当我们有了一个关键目标的时候，自然而然的回去思考还欠缺什么。而欠缺的，可能就是问题所在。

### 沉静的前行者

​		书中的原话是：“优秀的程序员，一定懂得妥协，懂得选择， 一步一步把事情沉静地朝前推动的人。”

​		首先，没有人是完美的。别人写的代码可能出现漏洞，我写的代码同样可能有漏洞。我们做的是看见我们的目标，然后坦然的面对我们的错误，解决他们，并且找到预防错误产生的方法。

### 可以依赖的伙伴

​		优秀的程序员是他人可以依赖的伙伴。

### 时间管理者

​		遇到问题时，去找解决问题的专家。这样子可以为我们节省很大一部分时间。

## 代码规范

​		代码规范毫无疑问是很重要的。我最早之前看阿里代码规范时，里面很明确的指出，所有的if后必须跟随大括号。我们可以回到之前苹果的goto fail案例。如果当时苹果出台类似于上述的规范，相信也不会出现goto fail的错误。

​		而代码规范本身是一项技能，越使用越高效。书中举了一个还不错的例子，3乘3的结果和13乘以23的结果，哪个更容易得出。相信大多数的人看到前者会很快的反应结果是9，而后者则要停下来好好算算了。

​		这是因为我们大脑中有一个快系统和慢系统。快系统类似于缓冲区，有的直接获取。慢系统用于处理复杂的计算。

​		如果我们把代码规范当做一个习惯的话，那么我会对一些不符合代码规范的代码极为敏感，就好比之前的苹果案例，我在写的时候已经感觉极为难受了。	w	

## 怎么给代码起一个好名字



## 代码注释，真的那么重要吗？



## 异常处理的陷阱

